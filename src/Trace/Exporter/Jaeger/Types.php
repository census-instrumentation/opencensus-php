<?php
namespace Jaeger\Thrift\Agent\Zipkin;

/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


final class AnnotationType {
  const BOOL = 0;
  const BYTES = 1;
  const I16 = 2;
  const I32 = 3;
  const I64 = 4;
  const DOUBLE = 5;
  const STRING = 6;
  static public $__names = array(
    0 => 'BOOL',
    1 => 'BYTES',
    2 => 'I16',
    3 => 'I32',
    4 => 'I64',
    5 => 'DOUBLE',
    6 => 'STRING',
  );
}

/**
 * Indicates the network context of a service recording an annotation with two
 * exceptions.
 * 
 * When a BinaryAnnotation, and key is CLIENT_ADDR or SERVER_ADDR,
 * the endpoint indicates the source or destination of an RPC. This exception
 * allows zipkin to display network context of uninstrumented services, or
 * clients such as web browsers.
 */
class Endpoint {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'ipv4',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    2 => array(
      'var' => 'port',
      'isRequired' => false,
      'type' => TType::I16,
      ),
    3 => array(
      'var' => 'service_name',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    4 => array(
      'var' => 'ipv6',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    );

  /**
   * IPv4 host address packed into 4 bytes.
   * 
   * Ex for the ip 1.2.3.4, it would be (1 << 24) | (2 << 16) | (3 << 8) | 4
   * 
   * @var int
   */
  public $ipv4 = null;
  /**
   * IPv4 port
   * 
   * Note: this is to be treated as an unsigned integer, so watch for negatives.
   * 
   * Conventionally, when the port isn't known, port = 0.
   * 
   * @var int
   */
  public $port = null;
  /**
   * Service name in lowercase, such as "memcache" or "zipkin-web"
   * 
   * Conventionally, when the service name isn't known, service_name = "unknown".
   * 
   * @var string
   */
  public $service_name = null;
  /**
   * IPv6 host address packed into 16 bytes. Ex Inet6Address.getBytes()
   * 
   * @var string
   */
  public $ipv6 = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['ipv4'])) {
        $this->ipv4 = $vals['ipv4'];
      }
      if (isset($vals['port'])) {
        $this->port = $vals['port'];
      }
      if (isset($vals['service_name'])) {
        $this->service_name = $vals['service_name'];
      }
      if (isset($vals['ipv6'])) {
        $this->ipv6 = $vals['ipv6'];
      }
    }
  }

  public function getName() {
    return 'Endpoint';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->ipv4);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->port);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->service_name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->ipv6);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Endpoint');
    if ($this->ipv4 !== null) {
      $xfer += $output->writeFieldBegin('ipv4', TType::I32, 1);
      $xfer += $output->writeI32($this->ipv4);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->port !== null) {
      $xfer += $output->writeFieldBegin('port', TType::I16, 2);
      $xfer += $output->writeI16($this->port);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->service_name !== null) {
      $xfer += $output->writeFieldBegin('service_name', TType::STRING, 3);
      $xfer += $output->writeString($this->service_name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ipv6 !== null) {
      $xfer += $output->writeFieldBegin('ipv6', TType::STRING, 4);
      $xfer += $output->writeString($this->ipv6);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * An annotation is similar to a log statement. It includes a host field which
 * allows these events to be attributed properly, and also aggregatable.
 */
class Annotation {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'timestamp',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    2 => array(
      'var' => 'value',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'host',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Jaeger\Thrift\Agent\Zipkin\Endpoint',
      ),
    );

  /**
   * Microseconds from epoch.
   * 
   * This value should use the most precise value possible. For example,
   * gettimeofday or syncing nanoTime against a tick of currentTimeMillis.
   * 
   * @var int
   */
  public $timestamp = null;
  /**
   * @var string
   */
  public $value = null;
  /**
   * Always the host that recorded the event. By specifying the host you allow
   * rollup of all events (such as client requests to a service) by IP address.
   * 
   * @var \Jaeger\Thrift\Agent\Zipkin\Endpoint
   */
  public $host = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
      if (isset($vals['host'])) {
        $this->host = $vals['host'];
      }
    }
  }

  public function getName() {
    return 'Annotation';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->host = new \Jaeger\Thrift\Agent\Zipkin\Endpoint();
            $xfer += $this->host->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Annotation');
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 1);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::STRING, 2);
      $xfer += $output->writeString($this->value);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->host !== null) {
      if (!is_object($this->host)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('host', TType::STRUCT, 3);
      $xfer += $this->host->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Binary annotations are tags applied to a Span to give it context. For
 * example, a binary annotation of "http.uri" could the path to a resource in a
 * RPC call.
 * 
 * Binary annotations of type STRING are always queryable, though more a
 * historical implementation detail than a structural concern.
 * 
 * Binary annotations can repeat, and vary on the host. Similar to Annotation,
 * the host indicates who logged the event. This allows you to tell the
 * difference between the client and server side of the same key. For example,
 * the key "http.uri" might be different on the client and server side due to
 * rewriting, like "/api/v1/myresource" vs "/myresource. Via the host field,
 * you can see the different points of view, which often help in debugging.
 */
class BinaryAnnotation {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'key',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    2 => array(
      'var' => 'value',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    3 => array(
      'var' => 'annotation_type',
      'isRequired' => false,
      'type' => TType::I32,
      ),
    4 => array(
      'var' => 'host',
      'isRequired' => false,
      'type' => TType::STRUCT,
      'class' => '\Jaeger\Thrift\Agent\Zipkin\Endpoint',
      ),
    );

  /**
   * @var string
   */
  public $key = null;
  /**
   * @var string
   */
  public $value = null;
  /**
   * @var int
   */
  public $annotation_type = null;
  /**
   * The host that recorded tag, which allows you to differentiate between
   * multiple tags with the same key. There are two exceptions to this.
   * 
   * When the key is CLIENT_ADDR or SERVER_ADDR, host indicates the source or
   * destination of an RPC. This exception allows zipkin to display network
   * context of uninstrumented services, or clients such as web browsers.
   * 
   * @var \Jaeger\Thrift\Agent\Zipkin\Endpoint
   */
  public $host = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['key'])) {
        $this->key = $vals['key'];
      }
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
      if (isset($vals['annotation_type'])) {
        $this->annotation_type = $vals['annotation_type'];
      }
      if (isset($vals['host'])) {
        $this->host = $vals['host'];
      }
    }
  }

  public function getName() {
    return 'BinaryAnnotation';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->key);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->annotation_type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->host = new \Jaeger\Thrift\Agent\Zipkin\Endpoint();
            $xfer += $this->host->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BinaryAnnotation');
    if ($this->key !== null) {
      $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
      $xfer += $output->writeString($this->key);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::STRING, 2);
      $xfer += $output->writeString($this->value);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->annotation_type !== null) {
      $xfer += $output->writeFieldBegin('annotation_type', TType::I32, 3);
      $xfer += $output->writeI32($this->annotation_type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->host !== null) {
      if (!is_object($this->host)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('host', TType::STRUCT, 4);
      $xfer += $this->host->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * A trace is a series of spans (often RPC calls) which form a latency tree.
 * 
 * The root span is where trace_id = id and parent_id = Nil. The root span is
 * usually the longest interval in the trace, starting with a SERVER_RECV
 * annotation and ending with a SERVER_SEND.
 */
class Span {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'trace_id',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    3 => array(
      'var' => 'name',
      'isRequired' => false,
      'type' => TType::STRING,
      ),
    4 => array(
      'var' => 'id',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    5 => array(
      'var' => 'parent_id',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    6 => array(
      'var' => 'annotations',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\Jaeger\Thrift\Agent\Zipkin\Annotation',
        ),
      ),
    8 => array(
      'var' => 'binary_annotations',
      'isRequired' => false,
      'type' => TType::LST,
      'etype' => TType::STRUCT,
      'elem' => array(
        'type' => TType::STRUCT,
        'class' => '\Jaeger\Thrift\Agent\Zipkin\BinaryAnnotation',
        ),
      ),
    9 => array(
      'var' => 'debug',
      'isRequired' => false,
      'type' => TType::BOOL,
      ),
    10 => array(
      'var' => 'timestamp',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    11 => array(
      'var' => 'duration',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    12 => array(
      'var' => 'trace_id_high',
      'isRequired' => false,
      'type' => TType::I64,
      ),
    );

  /**
   * @var int
   */
  public $trace_id = null;
  /**
   * Span name in lowercase, rpc method for example
   * 
   * Conventionally, when the span name isn't known, name = "unknown".
   * 
   * @var string
   */
  public $name = null;
  /**
   * @var int
   */
  public $id = null;
  /**
   * @var int
   */
  public $parent_id = null;
  /**
   * @var \Jaeger\Thrift\Agent\Zipkin\Annotation[]
   */
  public $annotations = null;
  /**
   * @var \Jaeger\Thrift\Agent\Zipkin\BinaryAnnotation[]
   */
  public $binary_annotations = null;
  /**
   * @var bool
   */
  public $debug = false;
  /**
   * Microseconds from epoch of the creation of this span.
   * 
   * This value should be set directly by instrumentation, using the most
   * precise value possible. For example, gettimeofday or syncing nanoTime
   * against a tick of currentTimeMillis.
   * 
   * For compatibilty with instrumentation that precede this field, collectors
   * or span stores can derive this via Annotation.timestamp.
   * For example, SERVER_RECV.timestamp or CLIENT_SEND.timestamp.
   * 
   * This field is optional for compatibility with old data: first-party span
   * stores are expected to support this at time of introduction.
   * 
   * @var int
   */
  public $timestamp = null;
  /**
   * Measurement of duration in microseconds, used to support queries.
   * 
   * This value should be set directly, where possible. Doing so encourages
   * precise measurement decoupled from problems of clocks, such as skew or NTP
   * updates causing time to move backwards.
   * 
   * For compatibilty with instrumentation that precede this field, collectors
   * or span stores can derive this by subtracting Annotation.timestamp.
   * For example, SERVER_SEND.timestamp - SERVER_RECV.timestamp.
   * 
   * If this field is persisted as unset, zipkin will continue to work, except
   * duration query support will be implementation-specific. Similarly, setting
   * this field non-atomically is implementation-specific.
   * 
   * This field is i64 vs i32 to support spans longer than 35 minutes.
   * 
   * @var int
   */
  public $duration = null;
  /**
   * Optional unique 8-byte additional identifier for a trace. If non zero, this
   * means the trace uses 128 bit traceIds instead of 64 bit.
   * 
   * @var int
   */
  public $trace_id_high = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['trace_id'])) {
        $this->trace_id = $vals['trace_id'];
      }
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['parent_id'])) {
        $this->parent_id = $vals['parent_id'];
      }
      if (isset($vals['annotations'])) {
        $this->annotations = $vals['annotations'];
      }
      if (isset($vals['binary_annotations'])) {
        $this->binary_annotations = $vals['binary_annotations'];
      }
      if (isset($vals['debug'])) {
        $this->debug = $vals['debug'];
      }
      if (isset($vals['timestamp'])) {
        $this->timestamp = $vals['timestamp'];
      }
      if (isset($vals['duration'])) {
        $this->duration = $vals['duration'];
      }
      if (isset($vals['trace_id_high'])) {
        $this->trace_id_high = $vals['trace_id_high'];
      }
    }
  }

  public function getName() {
    return 'Span';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->trace_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->parent_id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::LST) {
            $this->annotations = array();
            $_size0 = 0;
            $_etype3 = 0;
            $xfer += $input->readListBegin($_etype3, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $elem5 = null;
              $elem5 = new \Jaeger\Thrift\Agent\Zipkin\Annotation();
              $xfer += $elem5->read($input);
              $this->annotations []= $elem5;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::LST) {
            $this->binary_annotations = array();
            $_size6 = 0;
            $_etype9 = 0;
            $xfer += $input->readListBegin($_etype9, $_size6);
            for ($_i10 = 0; $_i10 < $_size6; ++$_i10)
            {
              $elem11 = null;
              $elem11 = new \Jaeger\Thrift\Agent\Zipkin\BinaryAnnotation();
              $xfer += $elem11->read($input);
              $this->binary_annotations []= $elem11;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->debug);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->timestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->duration);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->trace_id_high);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Span');
    if ($this->trace_id !== null) {
      $xfer += $output->writeFieldBegin('trace_id', TType::I64, 1);
      $xfer += $output->writeI64($this->trace_id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 3);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::I64, 4);
      $xfer += $output->writeI64($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parent_id !== null) {
      $xfer += $output->writeFieldBegin('parent_id', TType::I64, 5);
      $xfer += $output->writeI64($this->parent_id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->annotations !== null) {
      if (!is_array($this->annotations)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('annotations', TType::LST, 6);
      {
        $output->writeListBegin(TType::STRUCT, count($this->annotations));
        {
          foreach ($this->annotations as $iter12)
          {
            $xfer += $iter12->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->binary_annotations !== null) {
      if (!is_array($this->binary_annotations)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('binary_annotations', TType::LST, 8);
      {
        $output->writeListBegin(TType::STRUCT, count($this->binary_annotations));
        {
          foreach ($this->binary_annotations as $iter13)
          {
            $xfer += $iter13->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->debug !== null) {
      $xfer += $output->writeFieldBegin('debug', TType::BOOL, 9);
      $xfer += $output->writeBool($this->debug);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->timestamp !== null) {
      $xfer += $output->writeFieldBegin('timestamp', TType::I64, 10);
      $xfer += $output->writeI64($this->timestamp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->duration !== null) {
      $xfer += $output->writeFieldBegin('duration', TType::I64, 11);
      $xfer += $output->writeI64($this->duration);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->trace_id_high !== null) {
      $xfer += $output->writeFieldBegin('trace_id_high', TType::I64, 12);
      $xfer += $output->writeI64($this->trace_id_high);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Response {
  static $isValidate = false;

  static $_TSPEC = array(
    1 => array(
      'var' => 'ok',
      'isRequired' => true,
      'type' => TType::BOOL,
      ),
    );

  /**
   * @var bool
   */
  public $ok = null;

  public function __construct($vals=null) {
    if (is_array($vals)) {
      if (isset($vals['ok'])) {
        $this->ok = $vals['ok'];
      }
    }
  }

  public function getName() {
    return 'Response';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->ok);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Response');
    if ($this->ok !== null) {
      $xfer += $output->writeFieldBegin('ok', TType::BOOL, 1);
      $xfer += $output->writeBool($this->ok);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

final class Constant extends \Thrift\Type\TConstant {
  static protected $CLIENT_SEND;
  static protected $CLIENT_RECV;
  static protected $SERVER_SEND;
  static protected $SERVER_RECV;
  static protected $MESSAGE_SEND;
  static protected $MESSAGE_RECV;
  static protected $WIRE_SEND;
  static protected $WIRE_RECV;
  static protected $CLIENT_SEND_FRAGMENT;
  static protected $CLIENT_RECV_FRAGMENT;
  static protected $SERVER_SEND_FRAGMENT;
  static protected $SERVER_RECV_FRAGMENT;
  static protected $LOCAL_COMPONENT;
  static protected $CLIENT_ADDR;
  static protected $SERVER_ADDR;
  static protected $MESSAGE_ADDR;

  static protected function init_CLIENT_SEND() {
    return     /**
     * The client sent ("cs") a request to a server. There is only one send per
     * span. For example, if there's a transport error, each attempt can be logged
     * as a WIRE_SEND annotation.
     * 
     * If chunking is involved, each chunk could be logged as a separate
     * CLIENT_SEND_FRAGMENT in the same span.
     * 
     * Annotation.host is not the server. It is the host which logged the send
     * event, almost always the client. When logging CLIENT_SEND, instrumentation
     * should also log the SERVER_ADDR.
     */
"cs";
  }

  static protected function init_CLIENT_RECV() {
    return     /**
     * The client received ("cr") a response from a server. There is only one
     * receive per span. For example, if duplicate responses were received, each
     * can be logged as a WIRE_RECV annotation.
     * 
     * If chunking is involved, each chunk could be logged as a separate
     * CLIENT_RECV_FRAGMENT in the same span.
     * 
     * Annotation.host is not the server. It is the host which logged the receive
     * event, almost always the client. The actual endpoint of the server is
     * recorded separately as SERVER_ADDR when CLIENT_SEND is logged.
     */
"cr";
  }

  static protected function init_SERVER_SEND() {
    return     /**
     * The server sent ("ss") a response to a client. There is only one response
     * per span. If there's a transport error, each attempt can be logged as a
     * WIRE_SEND annotation.
     * 
     * Typically, a trace ends with a server send, so the last timestamp of a trace
     * is often the timestamp of the root span's server send.
     * 
     * If chunking is involved, each chunk could be logged as a separate
     * SERVER_SEND_FRAGMENT in the same span.
     * 
     * Annotation.host is not the client. It is the host which logged the send
     * event, almost always the server. The actual endpoint of the client is
     * recorded separately as CLIENT_ADDR when SERVER_RECV is logged.
     */
"ss";
  }

  static protected function init_SERVER_RECV() {
    return     /**
     * The server received ("sr") a request from a client. There is only one
     * request per span.  For example, if duplicate responses were received, each
     * can be logged as a WIRE_RECV annotation.
     * 
     * Typically, a trace starts with a server receive, so the first timestamp of a
     * trace is often the timestamp of the root span's server receive.
     * 
     * If chunking is involved, each chunk could be logged as a separate
     * SERVER_RECV_FRAGMENT in the same span.
     * 
     * Annotation.host is not the client. It is the host which logged the receive
     * event, almost always the server. When logging SERVER_RECV, instrumentation
     * should also log the CLIENT_ADDR.
     */
"sr";
  }

  static protected function init_MESSAGE_SEND() {
    return     /**
     * Message send ("ms") is a request to send a message to a destination, usually
     * a broker. This may be the only annotation in a messaging span. If WIRE_SEND
     * exists in the same span, it follows this moment and clarifies delays sending
     * the message, such as batching.
     * 
     * Unlike RPC annotations like CLIENT_SEND, messaging spans never share a span
     * ID. For example, "ms" should always be the parent of "mr".
     * 
     * Annotation.host is not the destination, it is the host which logged the send
     * event: the producer. When annotating MESSAGE_SEND, instrumentation should
     * also tag the MESSAGE_ADDR.
     */
"ms";
  }

  static protected function init_MESSAGE_RECV() {
    return     /**
     * A consumer received ("mr") a message from a broker. This may be the only
     * annotation in a messaging span. If WIRE_RECV exists in the same span, it
     * precedes this moment and clarifies any local queuing delay.
     * 
     * Unlike RPC annotations like SERVER_RECV, messaging spans never share a span
     * ID. For example, "mr" should always be a child of "ms" unless it is a root
     * span.
     * 
     * Annotation.host is not the broker, it is the host which logged the receive
     * event: the consumer.  When annotating MESSAGE_RECV, instrumentation should
     * also tag the MESSAGE_ADDR.
     */
"mr";
  }

  static protected function init_WIRE_SEND() {
    return     /**
     * Optionally logs an attempt to send a message on the wire. Multiple wire send
     * events could indicate network retries. A lag between client or server send
     * and wire send might indicate queuing or processing delay.
     */
"ws";
  }

  static protected function init_WIRE_RECV() {
    return     /**
     * Optionally logs an attempt to receive a message from the wire. Multiple wire
     * receive events could indicate network retries. A lag between wire receive
     * and client or server receive might indicate queuing or processing delay.
     */
"wr";
  }

  static protected function init_CLIENT_SEND_FRAGMENT() {
    return     /**
     * Optionally logs progress of a (CLIENT_SEND, WIRE_SEND). For example, this
     * could be one chunk in a chunked request.
     */
"csf";
  }

  static protected function init_CLIENT_RECV_FRAGMENT() {
    return     /**
     * Optionally logs progress of a (CLIENT_RECV, WIRE_RECV). For example, this
     * could be one chunk in a chunked response.
     */
"crf";
  }

  static protected function init_SERVER_SEND_FRAGMENT() {
    return     /**
     * Optionally logs progress of a (SERVER_SEND, WIRE_SEND). For example, this
     * could be one chunk in a chunked response.
     */
"ssf";
  }

  static protected function init_SERVER_RECV_FRAGMENT() {
    return     /**
     * Optionally logs progress of a (SERVER_RECV, WIRE_RECV). For example, this
     * could be one chunk in a chunked request.
     */
"srf";
  }

  static protected function init_LOCAL_COMPONENT() {
    return     /**
     * The value of "lc" is the component or namespace of a local span.
     * 
     * BinaryAnnotation.host adds service context needed to support queries.
     * 
     * Local Component("lc") supports three key features: flagging, query by
     * service and filtering Span.name by namespace.
     * 
     * While structurally the same, local spans are fundamentally different than
     * RPC spans in how they should be interpreted. For example, zipkin v1 tools
     * center on RPC latency and service graphs. Root local-spans are neither
     * indicative of critical path RPC latency, nor have impact on the shape of a
     * service graph. By flagging with "lc", tools can special-case local spans.
     * 
     * Zipkin v1 Spans are unqueryable unless they can be indexed by service name.
     * The only path to a service name is by (Binary)?Annotation.host.serviceName.
     * By logging "lc", a local span can be queried even if no other annotations
     * are logged.
     * 
     * The value of "lc" is the namespace of Span.name. For example, it might be
     * "finatra2", for a span named "bootstrap". "lc" allows you to resolves
     * conflicts for the same Span.name, for example "finatra/bootstrap" vs
     * "finch/bootstrap". Using local component, you'd search for spans named
     * "bootstrap" where "lc=finch"
     */
"lc";
  }

  static protected function init_CLIENT_ADDR() {
    return     /**
     * Indicates a client address ("ca") in a span. Most likely, there's only one.
     * Multiple addresses are possible when a client changes its ip or port within
     * a span.
     */
"ca";
  }

  static protected function init_SERVER_ADDR() {
    return     /**
     * Indicates a server address ("sa") in a span. Most likely, there's only one.
     * Multiple addresses are possible when a client is redirected, or fails to a
     * different server ip or port.
     */
"sa";
  }

  static protected function init_MESSAGE_ADDR() {
    return     /**
     * Indicates the remote address of a messaging span, usually the broker.
     */
"ma";
  }
}


